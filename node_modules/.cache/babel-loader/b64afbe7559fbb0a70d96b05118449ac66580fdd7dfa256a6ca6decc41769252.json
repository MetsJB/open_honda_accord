{"ast":null,"code":"import { useState, useEffect } from 'react';\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\nvar Direction;\n(function (Direction) {\n  Direction[\"X\"] = \"x\";\n  Direction[\"Y\"] = \"y\";\n})(Direction || (Direction = {}));\nvar getAttrMap = function getAttrMap(direction) {\n  return {\n    leftTop: Direction.X === direction ? 'left' : 'top',\n    offsetLeftTop: Direction.X === direction ? 'offsetLeft' : 'offsetTop',\n    offsetWidthHeight: Direction.X === direction ? 'offsetWidth' : 'offsetHeight',\n    scrollLeftTop: Direction.X === direction ? 'scrollLeft' : 'scrollTop',\n    scrollWidthHeight: Direction.X === direction ? 'scrollWidth' : 'scrollHeight',\n    clientWidthHeight: Direction.X === direction ? 'clientWidth' : 'clientHeight'\n  };\n};\nfunction debounce(cb, delay) {\n  if (delay === void 0) {\n    delay = 100;\n  }\n  var timer;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n    // @ts-ignore\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    var _this = this;\n    if (timer) clearTimeout(timer);\n    timer = setTimeout(function () {\n      cb.apply(_this, args);\n    }, delay);\n  };\n} // judge body or documentElement\n\nvar isWindowScrollParent = function isWindowScrollParent(elm) {\n  return !elm.parentElement || !elm.parentElement.parentElement;\n};\nvar getRelativeDistance = function getRelativeDistance(target, parent, attrMap) {\n  if (typeof target === 'number') return target;\n  if (typeof target === 'string') {\n    var elm = document.querySelector(target);\n    if (!elm) {\n      console.warn('Please pass correct selector string for scrollTo()!');\n      return 0;\n    }\n    var dis = 0; // if parent is document.documentElement or document.body\n\n    if (isWindowScrollParent(parent)) {\n      dis = elm.getBoundingClientRect()[attrMap.leftTop];\n    } else {\n      dis = elm.getBoundingClientRect()[attrMap.leftTop] - parent.getBoundingClientRect()[attrMap.leftTop];\n    }\n    return dis;\n  }\n  return 0;\n};\nvar useSmoothScroll = function useSmoothScroll(_ref) {\n  var ref = _ref.ref,\n    _ref$speed = _ref.speed,\n    speed = _ref$speed === void 0 ? 100 : _ref$speed,\n    _ref$direction = _ref.direction,\n    direction = _ref$direction === void 0 ? Direction.Y : _ref$direction,\n    _ref$threshold = _ref.threshold,\n    threshold = _ref$threshold === void 0 ? 1 : _ref$threshold;\n  var attrMap = getAttrMap(direction);\n  var _useState = useState(true),\n    reachedTop = _useState[0],\n    setReachedTop = _useState[1];\n  var _useState2 = useState(true),\n    reachedBottom = _useState2[0],\n    setReachedBottom = _useState2[1];\n  var _useState3 = useState(0),\n    size = _useState3[0],\n    setSize = _useState3[1];\n  var isTopEdge = function isTopEdge() {\n    var elm = ref.current;\n    if (!elm) return false;\n    return elm[attrMap.scrollLeftTop] === 0;\n  };\n  var isBottomEdge = function isBottomEdge() {\n    var elm = ref.current;\n    if (!elm) return false;\n    return Math.abs(elm[attrMap.scrollLeftTop] + elm[attrMap.clientWidthHeight] - elm[attrMap.scrollWidthHeight]) < threshold;\n  };\n  var refreshSize = debounce(function () {\n    if (ref.current) {\n      var _size = ref.current[attrMap.clientWidthHeight];\n      setSize(_size);\n    }\n  });\n  var refreshState = debounce(function (_evt) {\n    isTopEdge() ? setReachedTop(true) : setReachedTop(false);\n    isBottomEdge() ? setReachedBottom(true) : setReachedBottom(false);\n  });\n  var scrollTo = function scrollTo(target, offset) {\n    if (!ref || !ref.current) {\n      console.warn('Please pass `ref` property for your scroll container! \\n Get more info at https://github.com/ron0115/react-smooth-scroll-hook');\n      return;\n    }\n    var elm = ref.current;\n    if (!elm) return;\n    if (!target && typeof target !== 'number') {\n      console.warn('Please pass a valid property for `scrollTo()`! \\n Get more info at https://github.com/ron0115/react-smooth-scroll-hook');\n    }\n    var initScrollLeftTop = elm[attrMap.scrollLeftTop];\n    var distance = getRelativeDistance(target, elm, attrMap); // set a offset\n\n    if (typeof offset === 'number') {\n      distance += offset;\n    }\n    var _speed = speed;\n    var cb = function cb() {\n      refreshState();\n      if (distance === 0) return;\n      if (isBottomEdge() && distance > 9 || distance < 0 && isTopEdge()) return;\n      var gone = function gone() {\n        return Math.abs(elm[attrMap.scrollLeftTop] - initScrollLeftTop);\n      };\n      if (Math.abs(distance) - gone() < _speed) {\n        _speed = Math.abs(distance) - gone();\n      } // distance to run every frame，always 1/60s\n\n      elm[attrMap.scrollLeftTop] += _speed * (distance > 0 ? 1 : -1); // reach destination, threshold defaults to 1\n\n      if (Math.abs(gone() - Math.abs(distance)) < threshold) {\n        return;\n      }\n      requestAnimationFrame(cb);\n    };\n    requestAnimationFrame(cb);\n  }; // detect dom changes\n\n  useEffect(function () {\n    if (!ref.current) return;\n    refreshState();\n    refreshSize();\n    var observer = new MutationObserver(function (mutationsList, _observer) {\n      // Use traditional 'for loops' for IE 11\n      for (var _iterator = _createForOfIteratorHelperLoose(mutationsList), _step; !(_step = _iterator()).done;) {\n        var mutation = _step.value;\n        if (mutation.type === 'attributes' && mutation.target instanceof Element) {\n          refreshSize();\n        }\n      }\n    });\n    observer.observe(ref.current, {\n      attributes: true\n    });\n    window.addEventListener('resize', refreshSize);\n    return function () {\n      observer.disconnect();\n      window.removeEventListener('resize', refreshSize);\n    };\n  }, [ref, refreshState, refreshSize]); // detect scrollbar changes\n\n  useEffect(function () {\n    if (!ref.current) return;\n    var elm = ref.current;\n    var observer = new MutationObserver(function (mutationsList, _observer) {\n      // Use traditional 'for loops' for IE 11\n      for (var _iterator2 = _createForOfIteratorHelperLoose(mutationsList), _step2; !(_step2 = _iterator2()).done;) {\n        var mutation = _step2.value;\n        if (mutation.type === 'childList' && mutation.target instanceof Element) {\n          refreshState();\n        }\n      }\n    });\n    observer.observe(elm, {\n      childList: true,\n      subtree: true\n    });\n    elm.addEventListener('scroll', refreshState);\n    return function () {\n      observer.disconnect();\n      elm && elm.removeEventListener('scroll', refreshState);\n    };\n  }, [ref, refreshState]);\n  return {\n    reachedTop: reachedTop,\n    reachedBottom: reachedBottom,\n    containerSize: size,\n    scrollTo: scrollTo,\n    /** @deprecated replace with scrollTo(n * containerSize) */\n    scrollToPage: function scrollToPage(page) {\n      scrollTo(page * size);\n    },\n    /** @deprecated */\n    refreshState: refreshState,\n    /** @deprecated */\n    refreshSize: refreshSize\n  };\n};\nvar getCurIndex = function getCurIndex(scrollTop, list) {\n  var length = list.length;\n  if (!length) return -1;\n  for (var i = 0; i < length; i++) {\n    if (scrollTop < list[i]) {\n      return i - 1;\n    }\n  }\n  if (scrollTop >= list[length - 1]) {\n    return list.length - 1;\n  }\n  return -1;\n};\nvar useScrollWatch = function useScrollWatch(props) {\n  var ref = props.ref,\n    _props$list = props.list,\n    list = _props$list === void 0 ? [] : _props$list,\n    offset = props.offset,\n    _props$direction = props.direction,\n    direction = _props$direction === void 0 ? 'y' : _props$direction;\n  var attrMap = getAttrMap(direction);\n  var getScrollTop = function getScrollTop() {\n    var elm = ref.current;\n    if (!elm) return 0;\n    return elm[attrMap.scrollLeftTop];\n  };\n  var _useState = useState(getScrollTop() || 0),\n    scrollTop = _useState[0],\n    setScrollTop = _useState[1];\n  var getPosList = function getPosList() {\n    var posList = list.map(function (item) {\n      var parent = ref.current;\n      var os = typeof item.offset === 'number' ? item.offset : offset || 0;\n      var elm = document.querySelector(item.href);\n      if (!elm) return Infinity;\n      if (!parent) return Infinity;\n      return isWindowScrollParent(parent) ? elm.getBoundingClientRect()[attrMap.leftTop] - parent.getBoundingClientRect()[attrMap.leftTop] + os : elm.getBoundingClientRect()[attrMap.leftTop] - parent.children[0].getBoundingClientRect()[attrMap.leftTop] + os;\n    });\n    return posList;\n  };\n  var refresh = debounce(function () {\n    setScrollTop(getScrollTop());\n    setPosList(getPosList());\n  }, 100);\n  var _useState2 = useState([]),\n    posList = _useState2[0],\n    setPosList = _useState2[1];\n  useEffect(function () {\n    refresh();\n  }, [ref, refresh]);\n  var curIndex = getCurIndex(scrollTop, posList);\n  useEffect(function () {\n    if (!ref.current) return;\n    var elm = isWindowScrollParent(ref.current) ? window : ref.current;\n    var observer = new window.MutationObserver(refresh);\n    observer.observe(ref.current, {\n      childList: true,\n      subtree: true\n    });\n    elm.addEventListener('scroll', refresh);\n    return function () {\n      observer.disconnect();\n      elm && elm.removeEventListener('scroll', refresh);\n    };\n  }, [ref, refresh]);\n  return {\n    curIndex: curIndex,\n    scrollTop: scrollTop,\n    curItem: list[curIndex] || {}\n  };\n};\nexport default useSmoothScroll;\nexport { useScrollWatch, useSmoothScroll };","map":{"version":3,"names":["Direction","getAttrMap","direction","leftTop","X","offsetLeftTop","offsetWidthHeight","scrollLeftTop","scrollWidthHeight","clientWidthHeight","debounce","cb","delay","timer","args","Array","_len","_key","arguments","_this","clearTimeout","setTimeout","apply","isWindowScrollParent","elm","parentElement","getRelativeDistance","target","parent","attrMap","document","querySelector","console","warn","dis","getBoundingClientRect","useSmoothScroll","_ref","ref","speed","_ref$speed","_ref$direction","Y","threshold","_ref$threshold","useState","reachedTop","_useState","setReachedTop","reachedBottom","_useState2","setReachedBottom","size","_useState3","setSize","isTopEdge","current","isBottomEdge","Math","abs","refreshSize","_size","refreshState","_evt","scrollTo","offset","initScrollLeftTop","distance","_speed","gone","requestAnimationFrame","useEffect","observer","MutationObserver","mutationsList","_observer","_iterator","_createForOfIteratorHelperLoose","_step","done","mutation","value","type","Element","observe","attributes","window","addEventListener","disconnect","removeEventListener","_iterator2","_step2","childList","subtree","containerSize","scrollToPage","page","getCurIndex","scrollTop","list","length","i","useScrollWatch","props","_props$list","_props$direction","getScrollTop","setScrollTop","getPosList","posList","map","item","os","href","Infinity","children","refresh","setPosList","curIndex","curItem"],"sources":["C:\\Users\\Zahar\\Desktop\\Task\\frontend\\node_modules\\react-smooth-scroll-hook\\src\\utils.ts","C:\\Users\\Zahar\\Desktop\\Task\\frontend\\node_modules\\react-smooth-scroll-hook\\src\\useSmoothScroll.tsx","C:\\Users\\Zahar\\Desktop\\Task\\frontend\\node_modules\\react-smooth-scroll-hook\\src\\useScrollWatch.ts"],"sourcesContent":["export enum Direction {\n  X = 'x',\n  Y = 'y',\n}\nexport type DirectionType = Direction | 'x' | 'y';\nexport type AttrMapType = {\n  scrollLeftTop: 'scrollLeft' | 'scrollTop';\n  scrollWidthHeight: 'scrollWidth' | 'scrollHeight';\n  clientWidthHeight: 'clientWidth' | 'clientHeight';\n  offsetLeftTop: 'offsetLeft' | 'offsetTop';\n  offsetWidthHeight: 'offsetWidth' | 'offsetHeight';\n  leftTop: 'top' | 'left';\n};\nexport const getAttrMap = (direction: DirectionType) => {\n  return {\n    leftTop: Direction.X === direction ? 'left' : 'top',\n    offsetLeftTop: Direction.X === direction ? 'offsetLeft' : 'offsetTop',\n    offsetWidthHeight:\n      Direction.X === direction ? 'offsetWidth' : 'offsetHeight',\n    scrollLeftTop: Direction.X === direction ? 'scrollLeft' : 'scrollTop',\n    scrollWidthHeight:\n      Direction.X === direction ? 'scrollWidth' : 'scrollHeight',\n    clientWidthHeight:\n      Direction.X === direction ? 'clientWidth' : 'clientHeight',\n  } as AttrMapType;\n};\n\nexport function debounce(cb: Function, delay = 100) {\n  let timer: NodeJS.Timeout;\n  return function(...args: any) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n    // @ts-ignore\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const _this = this;\n    if (timer) clearTimeout(timer);\n    timer = setTimeout(() => {\n      cb.apply(_this, args);\n    }, delay);\n  };\n}\n\n// judge body or documentElement\nexport const isWindowScrollParent = (elm: HTMLElement) => {\n  return !elm.parentElement || !elm.parentElement.parentElement;\n};\n","import React, { useState } from 'react';\nimport { useEffect } from 'react';\nimport {\n  debounce,\n  getAttrMap,\n  AttrMapType,\n  Direction,\n  DirectionType,\n  isWindowScrollParent,\n} from './utils';\n\nexport type UseSmoothScrollType = {\n  /** the container dom RefObject which use `overflow:scroll`, if scroll whole document, pass `ref = useRef(document.documentElement)` or `useRef(document.body)`. */\n  ref: React.RefObject<HTMLElement>;\n  /** distance per frame, reflects to speed while scrolling */\n  speed?: number;\n  /** scroll direction, you can use 'x` for vertical, 'y` for horizontal */\n  direction?: DirectionType;\n  /** allowable distance beteween nowable state the judgement edge */\n  threshold?: number;\n};\n\n// get the relative distance from destination\nexport const getRelativeDistance = (\n  target: number | string | undefined,\n  parent: HTMLElement,\n  attrMap: AttrMapType\n) => {\n  if (typeof target === 'number') return target;\n  if (typeof target === 'string') {\n    const elm = document.querySelector(target);\n    if (!elm) {\n      console.warn('Please pass correct selector string for scrollTo()!');\n      return 0;\n    }\n    let dis = 0;\n\n    // if parent is document.documentElement or document.body\n    if (isWindowScrollParent(parent)) {\n      dis = elm.getBoundingClientRect()[attrMap.leftTop];\n    } else {\n      dis =\n        elm.getBoundingClientRect()[attrMap.leftTop] -\n        parent.getBoundingClientRect()[attrMap.leftTop];\n    }\n\n    return dis;\n  }\n  return 0;\n};\n\nexport const useSmoothScroll = ({\n  ref,\n  speed = 100,\n  direction = Direction.Y,\n  threshold = 1,\n}: UseSmoothScrollType) => {\n  const attrMap = getAttrMap(direction);\n\n  const [reachedTop, setReachedTop] = useState(true);\n  const [reachedBottom, setReachedBottom] = useState(true);\n  const [size, setSize] = useState(0);\n\n  const isTopEdge = () => {\n    const elm = ref.current;\n    if (!elm) return false;\n    return elm[attrMap.scrollLeftTop] === 0;\n  };\n\n  const isBottomEdge = () => {\n    const elm = ref.current;\n    if (!elm) return false;\n    return (\n      Math.abs(\n        elm[attrMap.scrollLeftTop] +\n          elm[attrMap.clientWidthHeight] -\n          elm[attrMap.scrollWidthHeight]\n      ) < threshold\n    );\n  };\n\n  const refreshSize = debounce(() => {\n    if (ref.current) {\n      const size = ref.current[attrMap.clientWidthHeight];\n      setSize(size);\n    }\n  });\n\n  const refreshState = debounce((_evt: Event) => {\n    isTopEdge() ? setReachedTop(true) : setReachedTop(false);\n    isBottomEdge() ? setReachedBottom(true) : setReachedBottom(false);\n  });\n\n  const scrollTo = (target?: number | string, offset?: number) => {\n    if (!ref || !ref.current) {\n      console.warn(\n        'Please pass `ref` property for your scroll container! \\n Get more info at https://github.com/ron0115/react-smooth-scroll-hook'\n      );\n      return;\n    }\n    const elm = ref.current;\n    if (!elm) return;\n    if (!target && typeof target !== 'number') {\n      console.warn(\n        'Please pass a valid property for `scrollTo()`! \\n Get more info at https://github.com/ron0115/react-smooth-scroll-hook'\n      );\n    }\n\n    const initScrollLeftTop = elm[attrMap.scrollLeftTop];\n\n    let distance = getRelativeDistance(target, elm, attrMap);\n\n    // set a offset\n    if (typeof offset === 'number') {\n      distance += offset;\n    }\n\n    let _speed = speed;\n    const cb = () => {\n      refreshState();\n\n      if (distance === 0) return;\n\n      if ((isBottomEdge() && distance > 9) || (distance < 0 && isTopEdge()))\n        return;\n\n      const gone = () =>\n        Math.abs(elm[attrMap.scrollLeftTop] - initScrollLeftTop);\n\n      if (Math.abs(distance) - gone() < _speed) {\n        _speed = Math.abs(distance) - gone();\n      }\n\n      // distance to run every frame，always 1/60s\n      elm[attrMap.scrollLeftTop] += _speed * (distance > 0 ? 1 : -1);\n\n      // reach destination, threshold defaults to 1\n      if (Math.abs(gone() - Math.abs(distance)) < threshold) {\n        return;\n      }\n\n      requestAnimationFrame(cb);\n    };\n    requestAnimationFrame(cb);\n  };\n\n  // detect dom changes\n  useEffect(() => {\n    if (!ref.current) return;\n\n    refreshState();\n    refreshSize();\n    const observer = new MutationObserver((mutationsList, _observer) => {\n      // Use traditional 'for loops' for IE 11\n      for (const mutation of mutationsList) {\n        if (\n          mutation.type === 'attributes' &&\n          mutation.target instanceof Element\n        ) {\n          refreshSize();\n        }\n      }\n    });\n    observer.observe(ref.current, {\n      attributes: true,\n    });\n    window.addEventListener('resize', refreshSize);\n    return () => {\n      observer.disconnect();\n      window.removeEventListener('resize', refreshSize);\n    };\n  }, [ref, refreshState, refreshSize]);\n\n  // detect scrollbar changes\n  useEffect(() => {\n    if (!ref.current) return;\n    const elm = ref.current;\n    const observer = new MutationObserver((mutationsList, _observer) => {\n      // Use traditional 'for loops' for IE 11\n      for (const mutation of mutationsList) {\n        if (\n          mutation.type === 'childList' &&\n          mutation.target instanceof Element\n        ) {\n          refreshState();\n        }\n      }\n    });\n    observer.observe(elm, {\n      childList: true,\n      subtree: true,\n    });\n    elm.addEventListener('scroll', refreshState);\n    return () => {\n      observer.disconnect();\n      elm && elm.removeEventListener('scroll', refreshState);\n    };\n  }, [ref, refreshState]);\n\n  return {\n    reachedTop,\n    reachedBottom,\n    containerSize: size,\n    scrollTo,\n    /** @deprecated replace with scrollTo(n * containerSize) */\n    scrollToPage: (page: number) => {\n      scrollTo(page * size);\n    },\n    /** @deprecated */\n    refreshState,\n    /** @deprecated */\n    refreshSize,\n  };\n};\nexport default useSmoothScroll;\n","import { useEffect, useState } from 'react';\nimport {\n  debounce,\n  DirectionType,\n  getAttrMap,\n  isWindowScrollParent,\n} from './utils';\n\nexport type useScrollWathType = {\n  /** the container dom RefObject which use `overflow:scroll`,if scroll whole document, pass `ref = useRef(document.documentElement)` or `useRef(document.body)`. */\n  ref: React.RefObject<HTMLElement>;\n  list: {\n    /** dom id of Element */\n    href: string;\n    /** the scroll position judge preset of each Element */\n    offset?: number;\n  }[];\n  /** global offset for every Element of list */\n  offset?: number;\n  /** scroll axis, x for horizontal, y for vertical */\n  direction?: DirectionType;\n};\n\nexport const getCurIndex = (scrollTop: number, list: number[]) => {\n  const length = list.length;\n  if (!length) return -1;\n\n  for (let i = 0; i < length; i++) {\n    if (scrollTop < list[i]) {\n      return i - 1;\n    }\n  }\n\n  if (scrollTop >= list[length - 1]) {\n    return list.length - 1;\n  }\n\n  return -1;\n};\n\nexport const useScrollWatch = (props: useScrollWathType) => {\n  const { ref, list = [], offset, direction = 'y' } = props;\n\n  const attrMap = getAttrMap(direction);\n\n  const getScrollTop = () => {\n    const elm = ref.current;\n    if (!elm) return 0;\n    return elm[attrMap.scrollLeftTop];\n  };\n\n  const [scrollTop, setScrollTop] = useState(getScrollTop() || 0);\n\n  const getPosList = () => {\n    let posList = list.map(item => {\n      const parent = ref.current;\n      const os = typeof item.offset === 'number' ? item.offset : offset || 0;\n      const elm = document.querySelector(item.href);\n      if (!elm) return Infinity;\n      if (!parent) return Infinity;\n      return isWindowScrollParent(parent)\n        ? elm.getBoundingClientRect()[attrMap.leftTop] -\n            parent.getBoundingClientRect()[attrMap.leftTop] +\n            os\n        : elm.getBoundingClientRect()[attrMap.leftTop] -\n            parent.children[0].getBoundingClientRect()[attrMap.leftTop] +\n            os;\n    });\n    return posList;\n  };\n\n  const refresh = debounce(() => {\n    setScrollTop(getScrollTop());\n    setPosList(getPosList());\n  }, 100);\n\n  const [posList, setPosList] = useState<number[]>([]);\n\n  useEffect(() => {\n    refresh();\n  }, [ref, refresh]);\n\n  const curIndex = getCurIndex(scrollTop, posList);\n\n  useEffect(() => {\n    if (!ref.current) return;\n    const elm = isWindowScrollParent(ref.current) ? window : ref.current;\n    const observer = new window.MutationObserver(refresh);\n    observer.observe(ref.current, {\n      childList: true,\n      subtree: true,\n    });\n    elm.addEventListener('scroll', refresh);\n    return () => {\n      observer.disconnect();\n      elm && elm.removeEventListener('scroll', refresh);\n    };\n  }, [ref, refresh]);\n\n  return {\n    curIndex,\n    scrollTop,\n    curItem: list[curIndex] || {},\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}